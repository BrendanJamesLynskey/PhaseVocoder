# Audio Time-Stretching & Pitch-Shifting Utilities

Three desktop applications for Windows 11 that manipulate audio using different mathematical approaches to time-frequency analysis. All three offer visualisation, microphone recording, and WAV export through identical UI layouts — making them ideal for comparing how STFT, CWT, and CQT handle the same audio material.

![Python](https://img.shields.io/badge/Python-3.10%2B-blue)
![Platform](https://img.shields.io/badge/Platform-Windows%2011-0078D6)
![License](https://img.shields.io/badge/License-MIT-green)

---

## Applications

### Phase Vocoder (`phase_vocoder.py`)

Uses the **Short-Time Fourier Transform (STFT)** — the industry-standard approach. The signal is divided into overlapping windowed frames, transformed to the frequency domain, and resynthesised via overlap-add after manipulating magnitude and phase.

**Time-stretching** works by reading through the spectrogram at a modified rate while accumulating phase at each bin's instantaneous frequency. **Pitch-shifting** combines time-stretching with polyphase resampling.

- Configurable FFT size (512–8192) and hop size (128–1024)
- Near-perfect reconstruction via COLA-compliant overlap-add
- Lower computational cost than the wavelet approach
- Best suited for tonal material (vocals, sustained instruments)

### Wavelet Processor (`wavelet_processor.py`)

Uses the **Continuous Wavelet Transform (CWT)** with Morlet wavelets. Instead of fixed-size FFT windows, the signal is analysed with wavelets whose time support adapts to frequency — short wavelets at high frequencies, long wavelets at low frequencies.

**Time-stretching** interpolates magnitude envelopes across scales and resynthesises phase by integrating the instantaneous frequency at each scale. A residual-preservation strategy maintains full-bandwidth fidelity. **Pitch-shifting** uses the same stretch-plus-resample approach.

- Configurable voices (24–96) and frequency range (20–20,000 Hz)
- Logarithmic frequency resolution matching human auditory perception
- Better transient preservation on percussive material
- Approximate reconstruction compensated by least-squares scaling

### CQT Processor (`cqt_processor.py`)

Uses the **Constant-Q Transform (CQT)** — a discrete, logarithmically-spaced frequency analysis that sits between the STFT and CWT. Each bin has a constant quality factor (centre frequency divided by bandwidth), giving musically meaningful resolution: semitone-spaced bins by default, with adaptive time resolution that shortens at high frequencies.

**Time-stretching** uses heterodyne phase unwrapping to extract true instantaneous frequencies from the CQ spectrogram, phase-locks adjacent bins to prevent spectral-leakage artefacts, and resynthesises via sample-level additive synthesis. **Pitch-shifting** uses the same stretch-plus-resample approach as the other two.

- Configurable bins per octave (12–48) and frequency range
- Logarithmic frequency grid aligned to musical intervals
- Heterodyne phase unwrapping handles large inter-frame phase advances
- Phase locking eliminates tone-splitting from spectral leakage
- Sample-level additive resynthesis avoids frame-based overlap-add artefacts

---

## Features

All three applications share an identical control layout:

- **Load WAV** or **record from microphone** (up to 30 seconds)
- **Time-stretch** from 0.25× to 4.0×
- **Pitch-shift** from −12 to +12 semitones
- **Side-by-side visualisation** — spectrograms (phase vocoder) or scalograms (wavelet)
- **Playback** of original and processed audio
- **Export** to WAV
- **Dark-themed UI** with parameter reset buttons

---

## Installation

### Requirements

- Python 3.10 or newer
- Windows 11 (audio I/O tested against WASAPI/DirectSound)

### Setup

```bash
git clone https://github.com/BrendanJamesLynskey/PhaseVocoder.git
cd audio-stretch-pitch
pip install -r requirements.txt
```

### Dependencies

```
numpy
scipy
sounddevice
soundfile
matplotlib
```

If `sounddevice` fails to install, you may need the [Visual C++ Redistributable](https://aka.ms/vs/17/release/vc_redist.x64.exe).

### Run

```bash
python phase_vocoder.py
python wavelet_processor.py
python cqt_processor.py
```

---

## How They Work

### Phase Vocoder — STFT Approach

```
Input → Window → FFT → [Spectrogram] → Interpolate magnitudes
                                       → Accumulate phase at instantaneous frequency
                                       → IFFT → Overlap-add → Output
```

1. The input is segmented into overlapping frames (default: 2048-sample Hann window, 512-sample hop = 75% overlap).
2. Each frame is FFT'd to produce a complex spectrogram with 1025 frequency bins.
3. For time-stretching, output frames are generated by stepping through the spectrogram at `1/stretch_factor` intervals. Magnitudes are linearly interpolated; phase is propagated by computing the instantaneous frequency from inter-frame phase differences, then accumulating at the synthesis rate.
4. The inverse FFT and overlap-add with squared-window normalisation reconstruct the time-domain signal.

### Wavelet Processor — CWT Approach

```
Input → CWT (Morlet) → [Scalogram] → Interpolate magnitudes
                                     → Integrate instantaneous frequency for phase
                                     → iCWT + residual blending → Output
```

1. The input is convolved with Morlet wavelets at 64 logarithmically-spaced scales spanning 20–20,000 Hz.
2. For time-stretching, the magnitude envelope and instantaneous frequency at each scale are interpolated to the target length. Phase is resynthesised by cumulative integration of the interpolated instantaneous frequency — this is the key to preserving pitch.
3. The inverse CWT reconstructs the wavelet-captured component, scaled by a least-squares factor. A separately resampled residual (energy the CWT doesn't capture) is added back for full-bandwidth output.

### CQT Processor — Constant-Q Approach

```
Input → CQT (per-bin convolution) → [CQ Spectrogram]
    → Heterodyne phase unwrapping → Phase locking
    → Interpolate magnitudes + instantaneous frequency to sample grid
    → Integrate phase → Additive synthesis + residual blending → Output
```

1. The input is convolved with per-bin windowed complex exponential kernels at 84 log-spaced frequencies (12 bins/octave, C1–C8 by default), downsampled at hop-size intervals.
2. True instantaneous frequencies are recovered via heterodyne unwrapping: the expected carrier phase advance is subtracted, the residual is wrapped to [−π, π], and the carrier is added back. This handles the large inter-frame phase advances (often 10+ full cycles) that defeat standard unwrapping.
3. Phase locking assigns every non-peak bin the instantaneous frequency of its nearest spectral peak, preventing leakage sidebands from creating phantom tones.
4. For each output sample, magnitude and instantaneous frequency are interpolated from the frame grid, and phase is obtained by cumulative integration. The output is the sum of all bins' cosine oscillators modulated by their interpolated magnitudes.
5. A resampled residual (energy not captured by the CQT) is blended back, and the output is RMS-matched to the input.

### Pitch Shifting (All Three)

All three applications use the same two-step strategy:

1. **Time-stretch** by the pitch ratio (2^(semitones/12)) — this changes duration without changing pitch.
2. **Resample** back to the target length — this shifts all frequencies by the desired ratio.

---

## Comparison

| | Phase Vocoder (STFT) | Wavelet Processor (CWT) | CQT Processor |
|---|---|---|---|
| **Frequency resolution** | Linear (uniform FFT bins) | Logarithmic (continuous scales) | Logarithmic (discrete bins) |
| **Time resolution** | Fixed by FFT window size | Adaptive (finer at high frequencies) | Adaptive (shorter kernels at high frequencies) |
| **Frequency grid** | Fixed by FFT size (e.g. 1025 bins) | User-defined continuous scales (e.g. 64 voices) | User-defined discrete bins (e.g. 12 per octave) |
| **Resynthesis** | Overlap-add (inverse FFT) | Weighted sum over scales (inverse CWT) | Sample-level additive synthesis |
| **Reconstruction** | Near-perfect (COLA overlap-add) | Approximate (residual-compensated) | Approximate (residual + RMS matched) |
| **Phase handling** | Standard bin-relative unwrapping | Standard per-sample unwrapping | Heterodyne unwrapping + phase locking |
| **Transient handling** | Can smear attacks | Better preservation | Intermediate (adaptive kernels, hop-limited) |
| **Computational cost** | Lowest | Highest | Medium |
| **Typical artefacts** | Metallic / phasey at extreme settings | Smoother but less precise | Clean on tonal; STFT residual stretch preserves pitch |
| **Best for** | Tonal material, moderate stretches | Percussive material, speech | Musical material, log-frequency analysis |

---

## Troubleshooting

### No sound on playback
All three apps use callback-based `sounddevice.OutputStream` for Windows reliability. If you still get no audio, check that your default output device supports 44100 Hz in Windows Sound Settings.

### `pip install sounddevice` fails
Install the [Visual C++ Redistributable](https://aka.ms/vs/17/release/vc_redist.x64.exe) and retry.

### `python` not recognised
Try `py` instead, or use the full path: `C:\Users\<you>\AppData\Local\Programs\Python\Python3xx\python.exe`.

### Processing is slow (wavelet / CQT)
The CWT is the most computationally expensive of the three approaches; the CQT is intermediate. For faster results, reduce the number of voices/bins per octave or narrow the frequency range.

---

## Project Structure

```
PhaseVocoder/
├── src/
│   ├── phase_vocoder.py          # STFT-based application
│   ├── wavelet_processor.py      # CWT-based application
│   └── cqt_processor.py          # CQT-based application
├── tests/
│   └── test_all.py               # Verification suite (90 tests across all 3 engines)
├── docs/
│   ├── phase_vocoder_report.docx # Technical report — STFT
│   ├── phase_vocoder_report.md   # Technical report — STFT (Markdown)
│   ├── wavelet_report.docx       # Technical report — CWT
│   ├── wavelet_report.md         # Technical report — CWT (Markdown)
│   ├── cqt_processor_report.docx # Technical report — CQT
│   └── cqt_processor_report.md   # Technical report — CQT (Markdown)
├── requirements.txt
└── README.md
```

---

## Technical Reports

Detailed technical reports are included in `docs/` as both Word documents (with equation-editor formatted mathematics) and Markdown:

- **phase_vocoder_report** — STFT analysis/synthesis, phase accumulation algorithm, overlap-add reconstruction
- **wavelet_report** — Morlet wavelet, CWT/iCWT, instantaneous frequency phase synthesis, residual preservation
- **cqt_processor_report** — CQT analysis kernels, heterodyne phase unwrapping, phase locking, sample-level additive resynthesis

## Testing

Run the full verification suite (90 tests across all three engines):

```bash
python tests/test_all.py
```

Tests cover duration accuracy, pitch preservation, pitch-shift accuracy, harmonic structure, phantom tone absence, level consistency, identity transforms, extreme stretch factors, octave round-trips, and short signal handling.

---

## Acknowledgements

Built with [NumPy](https://numpy.org/), [SciPy](https://scipy.org/), [sounddevice](https://python-sounddevice.readthedocs.io/), [SoundFile](https://pysoundfile.readthedocs.io/), and [Matplotlib](https://matplotlib.org/).
